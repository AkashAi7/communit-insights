{"version":3,"sources":["../src/mcp-client-plugin.ts"],"names":["ConsoleLogger","buildSSEClientTransport","Client"],"mappings":"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","file":"mcp-client-plugin.js","sourcesContent":["import { Client, ClientOptions } from '@modelcontextprotocol/sdk/client/index.js';\n\nimport { ChatPromptPlugin, Function, Schema } from '@microsoft/teams.ai';\n\nimport { ConsoleLogger, ILogger } from '@microsoft/teams.common';\n\nimport {\n  CreateTransport,\n  McpClientPluginCachedValue,\n  McpClientPluginOptions,\n  McpClientPluginParams,\n  McpClientPluginUseParams,\n  McpClientToolDetails,\n  ValueOrFactory,\n} from './mcp-client-types';\nimport { buildSSEClientTransport } from './mcp-transport';\n\nexport class McpClientPlugin implements ChatPromptPlugin<'mcpClient', McpClientPluginUseParams> {\n  readonly name = 'mcpClient';\n\n  // This collides with the name of the plugin, so we use a different\n  // variable name\n  get mcpClientName() {\n    return this._name;\n  }\n  protected readonly _name: string;\n\n  get version() {\n    return this._version;\n  }\n  protected readonly _version: string;\n\n  get clientOptions() {\n    return this._clientOptions;\n  }\n  protected _clientOptions: ClientOptions;\n\n  get cache() {\n    return this._cache;\n  }\n  protected _cache: Record<string, McpClientPluginCachedValue & { lastAttemptedFetch?: number }>;\n\n  get log() {\n    return this._log;\n  }\n  protected readonly _log: ILogger;\n\n  get refetchTimeoutMs() {\n    return this._refetchTimeoutMs;\n  }\n  protected _refetchTimeoutMs: number;\n\n  private readonly _mcpServerUrlsByParams: Record<string, McpClientPluginParams | undefined> = {};\n\n  private createTransport: CreateTransport | null;\n\n  constructor(options?: McpClientPluginOptions) {\n    const {\n      name: mcpClientName,\n      version,\n      cache,\n      createTransport,\n      logger,\n      refetchTimeoutMs,\n      ...clientOptions\n    } = options || {};\n    this._name = mcpClientName || 'mcpClient';\n    this._version = version || '0.0.0';\n    if (cache != null) {\n      this._cache = {};\n      for (const [url, params] of Object.entries(cache)) {\n        this._cache[url] = {\n          ...params,\n          lastAttemptedFetch: Date.now(),\n        };\n      }\n    } else {\n      this._cache = {};\n    }\n    this._clientOptions = clientOptions;\n    this.createTransport = createTransport ?? null;\n    this._log = logger?.child(this._name) || new ConsoleLogger(this._name);\n    this._refetchTimeoutMs = refetchTimeoutMs || 24 * 60 * 60 * 1000; // 1 day\n  }\n\n  onUsePlugin(args: { url: string; params?: McpClientPluginParams }) {\n    this._mcpServerUrlsByParams[args.url] = args.params;\n    if (args.params?.availableTools && args.params.availableTools.length > 0) {\n      this._cache[args.url] = {\n        ...this._cache[args.url],\n        // If the tools are being supplied, we assume they are up to date\n        lastAttemptedFetch: Date.now(),\n        availableTools: args.params.availableTools,\n      };\n    }\n  }\n\n  async onBuildFunctions(incomingFunctions: Function[]): Promise<Function[]> {\n    await this.fetchToolsIfNeeded();\n\n    // Now create all functions\n    const allFunctions: Function[] = [];\n\n    for (const [url, params] of Object.entries(this._mcpServerUrlsByParams)) {\n      const availableTools = this._cache[url]?.availableTools;\n      if (!availableTools) {\n        // If we don't have any tools, we can't create any functions\n        continue;\n      }\n\n      const functions = availableTools.map((availableTool) => ({\n        name: availableTool.name,\n        description: availableTool.description,\n        parameters: availableTool.schema || {},\n        handler: async (args: any) => {\n          const [client, transport] = await this.makeMcpClient(url, params?.headers);\n          try {\n            await client.connect(transport);\n            const result = await client.callTool({\n              name: availableTool.name,\n              arguments: args,\n            });\n\n            return result.content;\n          } finally {\n            await client.close();\n          }\n        },\n      }));\n\n      allFunctions.push(...functions);\n    }\n\n    return incomingFunctions.concat(allFunctions);\n  }\n\n  private async fetchToolsIfNeeded() {\n    // First, handle all fetching needs\n    const fetchNeededObjects = Object.entries(this._mcpServerUrlsByParams)\n      .map(([url, params]) => {\n        // If availableTools are being supplied, then we use them\n        // and don't need to fetch anything\n        if (params?.availableTools) {\n          return null;\n        }\n\n        const cachedParams = this._cache[url];\n        if (cachedParams?.availableTools == null || cachedParams.availableTools.length === 0) {\n          // If we don't have a cached value, we need to fetch\n          return { url, ...params };\n        }\n\n        const maxAge = params?.refetchTimeoutMs ?? this.refetchTimeoutMs;\n        if (\n          !cachedParams.lastAttemptedFetch ||\n          Date.now() - cachedParams.lastAttemptedFetch > maxAge\n        ) {\n          // If we have a cached value and it's still valid, we don't need to fetch\n          return { url, ...params };\n        }\n\n        return null;\n      })\n      .filter((res): res is NonNullable<typeof res> => res != null);\n\n    // Fetch all needed params in parallel\n    if (fetchNeededObjects.length > 0) {\n      const allFetchedTools = await this.getTools(fetchNeededObjects);\n      for (const [url, tools] of Object.entries(allFetchedTools)) {\n        this._cache[url] = {\n          ...this._cache[url],\n          lastAttemptedFetch: tools === 'unavailable' ? undefined : Date.now(),\n          availableTools: tools === 'unavailable' ? undefined : tools,\n        };\n        if (tools === 'unavailable') {\n          this.log.warn(`Tools unavailable for URL: ${url}`);\n        } else {\n          this.log.debug(`Cached ${tools.length} tools for URL: ${url}`);\n        }\n      }\n    }\n  }\n\n  private async getTools(\n    params: ({ url: string } & Pick<McpClientPluginParams, 'headers' | 'skipIfUnavailable'>)[]\n  ): Promise<Record<string, McpClientToolDetails[] | 'unavailable'>> {\n    const toolCallResult = await Promise.all(\n      params.map(async ({ url, headers, skipIfUnavailable }) => {\n        const tools = await this.fetchTools(url, headers, skipIfUnavailable);\n        return [url, tools];\n      })\n    );\n\n    return Object.fromEntries(toolCallResult);\n  }\n\n  private async fetchTools(\n    url: string,\n    headers?: ValueOrFactory<Record<string, string>>,\n    skipIfUnavailable?: boolean\n  ): Promise<McpClientToolDetails[] | 'unavailable'> {\n    const [client, transport] = await this.makeMcpClient(url, headers);\n    try {\n      await client.connect(transport);\n      const listToolsResult = await client.listTools();\n      this.log.debug(`Successfully discovered ${listToolsResult.tools.length} tools from ${url}`);\n      this.log.debug('Tools discovered:', JSON.stringify(listToolsResult.tools, null, 2));\n      return listToolsResult.tools.map((tool) => ({\n        name: tool.name,\n        description: tool.description ?? '',\n        schema: tool.inputSchema as Schema,\n      }));\n    } catch (e) {\n      this.log.error(`Error fetching tools from ${url}:`, e);\n      if (skipIfUnavailable || skipIfUnavailable == null) {\n        return 'unavailable';\n      }\n      throw e;\n    } finally {\n      await client.close();\n    }\n  }\n\n  private async makeMcpClient(\n    serverUrl: string,\n    headers: ValueOrFactory<Record<string, string>> | undefined\n  ) {\n    const transport = this.createTransport\n      ? this.createTransport(serverUrl)\n      : await buildSSEClientTransport(serverUrl, headers);\n\n    const client = new Client(\n      {\n        name: this._name,\n        version: this._version,\n      },\n      this._clientOptions\n    );\n\n    return [client, transport] as const;\n  }\n}\n"]}