'use strict';

var index_js = require('@modelcontextprotocol/sdk/client/index.js');
var teams_common = require('@microsoft/teams.common');
var mcpTransport = require('./mcp-transport');

class McpClientPlugin {
  name = "mcpClient";
  // This collides with the name of the plugin, so we use a different
  // variable name
  get mcpClientName() {
    return this._name;
  }
  _name;
  get version() {
    return this._version;
  }
  _version;
  get clientOptions() {
    return this._clientOptions;
  }
  _clientOptions;
  get cache() {
    return this._cache;
  }
  _cache;
  get log() {
    return this._log;
  }
  _log;
  get refetchTimeoutMs() {
    return this._refetchTimeoutMs;
  }
  _refetchTimeoutMs;
  _mcpServerUrlsByParams = {};
  createTransport;
  constructor(options) {
    const {
      name: mcpClientName,
      version,
      cache,
      createTransport,
      logger,
      refetchTimeoutMs,
      ...clientOptions
    } = options || {};
    this._name = mcpClientName || "mcpClient";
    this._version = version || "0.0.0";
    if (cache != null) {
      this._cache = {};
      for (const [url, params] of Object.entries(cache)) {
        this._cache[url] = {
          ...params,
          lastAttemptedFetch: Date.now()
        };
      }
    } else {
      this._cache = {};
    }
    this._clientOptions = clientOptions;
    this.createTransport = createTransport ?? null;
    this._log = logger?.child(this._name) || new teams_common.ConsoleLogger(this._name);
    this._refetchTimeoutMs = refetchTimeoutMs || 24 * 60 * 60 * 1e3;
  }
  onUsePlugin(args) {
    this._mcpServerUrlsByParams[args.url] = args.params;
    if (args.params?.availableTools && args.params.availableTools.length > 0) {
      this._cache[args.url] = {
        ...this._cache[args.url],
        // If the tools are being supplied, we assume they are up to date
        lastAttemptedFetch: Date.now(),
        availableTools: args.params.availableTools
      };
    }
  }
  async onBuildFunctions(incomingFunctions) {
    await this.fetchToolsIfNeeded();
    const allFunctions = [];
    for (const [url, params] of Object.entries(this._mcpServerUrlsByParams)) {
      const availableTools = this._cache[url]?.availableTools;
      if (!availableTools) {
        continue;
      }
      const functions = availableTools.map((availableTool) => ({
        name: availableTool.name,
        description: availableTool.description,
        parameters: availableTool.schema || {},
        handler: async (args) => {
          const [client, transport] = await this.makeMcpClient(url, params?.headers);
          try {
            await client.connect(transport);
            const result = await client.callTool({
              name: availableTool.name,
              arguments: args
            });
            return result.content;
          } finally {
            await client.close();
          }
        }
      }));
      allFunctions.push(...functions);
    }
    return incomingFunctions.concat(allFunctions);
  }
  async fetchToolsIfNeeded() {
    const fetchNeededObjects = Object.entries(this._mcpServerUrlsByParams).map(([url, params]) => {
      if (params?.availableTools) {
        return null;
      }
      const cachedParams = this._cache[url];
      if (cachedParams?.availableTools == null || cachedParams.availableTools.length === 0) {
        return { url, ...params };
      }
      const maxAge = params?.refetchTimeoutMs ?? this.refetchTimeoutMs;
      if (!cachedParams.lastAttemptedFetch || Date.now() - cachedParams.lastAttemptedFetch > maxAge) {
        return { url, ...params };
      }
      return null;
    }).filter((res) => res != null);
    if (fetchNeededObjects.length > 0) {
      const allFetchedTools = await this.getTools(fetchNeededObjects);
      for (const [url, tools] of Object.entries(allFetchedTools)) {
        this._cache[url] = {
          ...this._cache[url],
          lastAttemptedFetch: tools === "unavailable" ? void 0 : Date.now(),
          availableTools: tools === "unavailable" ? void 0 : tools
        };
        if (tools === "unavailable") {
          this.log.warn(`Tools unavailable for URL: ${url}`);
        } else {
          this.log.debug(`Cached ${tools.length} tools for URL: ${url}`);
        }
      }
    }
  }
  async getTools(params) {
    const toolCallResult = await Promise.all(
      params.map(async ({ url, headers, skipIfUnavailable }) => {
        const tools = await this.fetchTools(url, headers, skipIfUnavailable);
        return [url, tools];
      })
    );
    return Object.fromEntries(toolCallResult);
  }
  async fetchTools(url, headers, skipIfUnavailable) {
    const [client, transport] = await this.makeMcpClient(url, headers);
    try {
      await client.connect(transport);
      const listToolsResult = await client.listTools();
      this.log.debug(`Successfully discovered ${listToolsResult.tools.length} tools from ${url}`);
      this.log.debug("Tools discovered:", JSON.stringify(listToolsResult.tools, null, 2));
      return listToolsResult.tools.map((tool) => ({
        name: tool.name,
        description: tool.description ?? "",
        schema: tool.inputSchema
      }));
    } catch (e) {
      this.log.error(`Error fetching tools from ${url}:`, e);
      if (skipIfUnavailable || skipIfUnavailable == null) {
        return "unavailable";
      }
      throw e;
    } finally {
      await client.close();
    }
  }
  async makeMcpClient(serverUrl, headers) {
    const transport = this.createTransport ? this.createTransport(serverUrl) : await mcpTransport.buildSSEClientTransport(serverUrl, headers);
    const client = new index_js.Client(
      {
        name: this._name,
        version: this._version
      },
      this._clientOptions
    );
    return [client, transport];
  }
}

exports.McpClientPlugin = McpClientPlugin;
//# sourceMappingURL=mcp-client-plugin.js.map
//# sourceMappingURL=mcp-client-plugin.js.map